#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 4 1 8
    bytecblock 0x151f7c75 0x0001 "admin" "" 0x0000 0x068101 "appID"
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/escreg/contract.algo.ts:31
    // admin = GlobalState<Address>({ initialValue: new Address(Txn.sender) })
    bytec_2 // "admin"
    txn Sender
    app_global_put

main_after_if_else@2:
    // smart_contracts/escreg/contract.algo.ts:29
    // export class Escreg extends Contract implements ConventionalRouting {
    txn NumAppArgs
    bz main_bare_routing@19
    pushbytess 0x2487c32c 0x46f76533 0x21f1ddff 0xf7e99a83 0x72bf6dc4 0x4c9fb656 0x89e79924 0x40e65262 0x193625f8 0x90c9550f 0xb561c256 0x82b435f8 // method "deleteApplication()void", method "updateApplication()void", method "withdraw(uint64)void", method "register(uint64)void", method "registerList(uint64[])void", method "exists(address)bool", method "get(address)uint64", method "mustGet(address)uint64", method "getWithAuth(address)(uint64,uint64)", method "getWithAuthList(address[])(uint64,uint64)[]", method "getList(address[])uint64[]", method "mustGetList(address[])uint64[]"
    txna ApplicationArgs 0
    match main_deleteApplication_route@5 main_updateApplication_route@6 main_withdraw_route@7 main_register_route@8 main_registerList_route@9 main_exists_route@10 main_get_route@11 main_mustGet_route@12 main_getWithAuth_route@13 main_getWithAuthList_route@14 main_getList_route@15 main_mustGetList_route@16

main_after_if_else@23:
    // smart_contracts/escreg/contract.algo.ts:29
    // export class Escreg extends Contract implements ConventionalRouting {
    intc_0 // 0
    return

main_mustGetList_route@16:
    // smart_contracts/escreg/contract.algo.ts:216
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/escreg/contract.algo.ts:29
    // export class Escreg extends Contract implements ConventionalRouting {
    txna ApplicationArgs 1
    // smart_contracts/escreg/contract.algo.ts:216
    // @abimethod({ readonly: true })
    callsub mustGetList
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    return

main_getList_route@15:
    // smart_contracts/escreg/contract.algo.ts:195
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/escreg/contract.algo.ts:29
    // export class Escreg extends Contract implements ConventionalRouting {
    txna ApplicationArgs 1
    // smart_contracts/escreg/contract.algo.ts:195
    // @abimethod({ readonly: true })
    callsub getList
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    return

main_getWithAuthList_route@14:
    // smart_contracts/escreg/contract.algo.ts:167
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/escreg/contract.algo.ts:29
    // export class Escreg extends Contract implements ConventionalRouting {
    txna ApplicationArgs 1
    // smart_contracts/escreg/contract.algo.ts:167
    // @abimethod({ readonly: true })
    callsub getWithAuthList
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    return

main_getWithAuth_route@13:
    // smart_contracts/escreg/contract.algo.ts:145
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/escreg/contract.algo.ts:29
    // export class Escreg extends Contract implements ConventionalRouting {
    txna ApplicationArgs 1
    // smart_contracts/escreg/contract.algo.ts:145
    // @abimethod({ readonly: true })
    callsub getWithAuth
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    return

main_mustGet_route@12:
    // smart_contracts/escreg/contract.algo.ts:131
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/escreg/contract.algo.ts:29
    // export class Escreg extends Contract implements ConventionalRouting {
    txna ApplicationArgs 1
    // smart_contracts/escreg/contract.algo.ts:131
    // @abimethod({ readonly: true })
    callsub mustGet
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    return

main_get_route@11:
    // smart_contracts/escreg/contract.algo.ts:117
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/escreg/contract.algo.ts:29
    // export class Escreg extends Contract implements ConventionalRouting {
    txna ApplicationArgs 1
    // smart_contracts/escreg/contract.algo.ts:117
    // @abimethod({ readonly: true })
    callsub get
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    return

main_exists_route@10:
    // smart_contracts/escreg/contract.algo.ts:103
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/escreg/contract.algo.ts:29
    // export class Escreg extends Contract implements ConventionalRouting {
    txna ApplicationArgs 1
    // smart_contracts/escreg/contract.algo.ts:103
    // @abimethod({ readonly: true })
    callsub exists
    pushbytes 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    return

main_registerList_route@9:
    // smart_contracts/escreg/contract.algo.ts:61
    // public registerList(appIds: uint64[]): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/escreg/contract.algo.ts:29
    // export class Escreg extends Contract implements ConventionalRouting {
    txna ApplicationArgs 1
    // smart_contracts/escreg/contract.algo.ts:61
    // public registerList(appIds: uint64[]): void {
    callsub registerList
    intc_2 // 1
    return

main_register_route@8:
    // smart_contracts/escreg/contract.algo.ts:52
    // public register(appId: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/escreg/contract.algo.ts:29
    // export class Escreg extends Contract implements ConventionalRouting {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/escreg/contract.algo.ts:52
    // public register(appId: uint64): void {
    callsub register
    intc_2 // 1
    return

main_withdraw_route@7:
    // smart_contracts/escreg/contract.algo.ts:41
    // public withdraw(amount: uint64) {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/escreg/contract.algo.ts:29
    // export class Escreg extends Contract implements ConventionalRouting {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/escreg/contract.algo.ts:41
    // public withdraw(amount: uint64) {
    callsub withdraw
    intc_2 // 1
    return

main_updateApplication_route@6:
    // smart_contracts/escreg/contract.algo.ts:37
    // public updateApplication() {
    txn OnCompletion
    intc_1 // UpdateApplication
    ==
    assert // OnCompletion is not UpdateApplication
    txn ApplicationID
    assert // can only call when not creating
    callsub updateApplication
    intc_2 // 1
    return

main_deleteApplication_route@5:
    // smart_contracts/escreg/contract.algo.ts:33
    // public deleteApplication() {
    txn OnCompletion
    pushint 5 // DeleteApplication
    ==
    assert // OnCompletion is not DeleteApplication
    txn ApplicationID
    assert // can only call when not creating
    callsub deleteApplication
    intc_2 // 1
    return

main_bare_routing@19:
    // smart_contracts/escreg/contract.algo.ts:29
    // export class Escreg extends Contract implements ConventionalRouting {
    txn OnCompletion
    bnz main_after_if_else@23
    txn ApplicationID
    !
    assert // can only call when creating
    intc_2 // 1
    return


// _puya_lib.util.ensure_budget(required_budget: uint64, fee_source: uint64) -> void:
ensure_budget:
    proto 2 0
    frame_dig -2
    pushint 10 // 10
    +

ensure_budget_while_top@1:
    frame_dig 0
    global OpcodeBudget
    >
    bz ensure_budget_after_while@7
    itxn_begin
    pushint 6 // appl
    itxn_field TypeEnum
    pushint 5 // DeleteApplication
    itxn_field OnCompletion
    bytec 5 // 0x068101
    itxn_field ApprovalProgram
    bytec 5 // 0x068101
    itxn_field ClearStateProgram
    frame_dig -1
    switch ensure_budget_switch_case_0@3 ensure_budget_switch_case_1@4

ensure_budget_switch_case_next@6:
    itxn_submit
    b ensure_budget_while_top@1

ensure_budget_switch_case_1@4:
    global MinTxnFee
    itxn_field Fee
    b ensure_budget_switch_case_next@6

ensure_budget_switch_case_0@3:
    intc_0 // 0
    itxn_field Fee
    b ensure_budget_switch_case_next@6

ensure_budget_after_while@7:
    retsub


// smart_contracts/escreg/contract.algo.ts::Escreg.deleteApplication() -> void:
deleteApplication:
    // smart_contracts/escreg/contract.algo.ts:34
    // assert(Txn.sender === this.admin.value.native, ERR_UNAUTH)
    txn Sender
    intc_0 // 0
    // smart_contracts/escreg/contract.algo.ts:31
    // admin = GlobalState<Address>({ initialValue: new Address(Txn.sender) })
    bytec_2 // "admin"
    // smart_contracts/escreg/contract.algo.ts:34
    // assert(Txn.sender === this.admin.value.native, ERR_UNAUTH)
    app_global_get_ex
    assert // check GlobalState exists
    ==
    assert // ERR:UNAUTH
    retsub


// smart_contracts/escreg/contract.algo.ts::Escreg.updateApplication() -> void:
updateApplication:
    // smart_contracts/escreg/contract.algo.ts:38
    // assert(Txn.sender === this.admin.value.native, ERR_UNAUTH)
    txn Sender
    intc_0 // 0
    // smart_contracts/escreg/contract.algo.ts:31
    // admin = GlobalState<Address>({ initialValue: new Address(Txn.sender) })
    bytec_2 // "admin"
    // smart_contracts/escreg/contract.algo.ts:38
    // assert(Txn.sender === this.admin.value.native, ERR_UNAUTH)
    app_global_get_ex
    assert // check GlobalState exists
    ==
    assert // ERR:UNAUTH
    retsub


// smart_contracts/escreg/contract.algo.ts::Escreg.withdraw(amount: uint64) -> void:
withdraw:
    // smart_contracts/escreg/contract.algo.ts:41
    // public withdraw(amount: uint64) {
    proto 1 0
    // smart_contracts/escreg/contract.algo.ts:42
    // assert(Txn.sender === this.admin.value.native, ERR_UNAUTH)
    txn Sender
    intc_0 // 0
    // smart_contracts/escreg/contract.algo.ts:31
    // admin = GlobalState<Address>({ initialValue: new Address(Txn.sender) })
    bytec_2 // "admin"
    // smart_contracts/escreg/contract.algo.ts:42
    // assert(Txn.sender === this.admin.value.native, ERR_UNAUTH)
    app_global_get_ex
    assert // check GlobalState exists
    ==
    assert // ERR:UNAUTH
    // smart_contracts/escreg/contract.algo.ts:44-49
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/escreg/contract.algo.ts:46
    // receiver: Txn.sender,
    txn Sender
    frame_dig -1
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/escreg/contract.algo.ts:44-48
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount,
    //   })
    intc_2 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/escreg/contract.algo.ts:44-49
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount,
    //   })
    //   .submit()
    itxn_submit
    retsub


// smart_contracts/escreg/contract.algo.ts::Escreg.register(appId: uint64) -> void:
register:
    // smart_contracts/escreg/contract.algo.ts:52
    // public register(appId: uint64): void {
    proto 1 0
    // smart_contracts/escreg/contract.algo.ts:53
    // const key = this.deriveAddrPrefix(appId)
    frame_dig -1
    callsub deriveAddrPrefix
    dup
    // smart_contracts/escreg/contract.algo.ts:54
    // if (!this.apps(key).exists) {
    box_len
    bury 1
    bnz register_else_body@2
    // smart_contracts/escreg/contract.algo.ts:55
    // this.apps(key).value = [appId]
    frame_dig -1
    itob
    bytec_1 // 0x0001
    swap
    concat
    swap
    dup
    box_del
    pop
    swap
    box_put
    retsub

register_else_body@2:
    // smart_contracts/escreg/contract.algo.ts:57
    // this.appendAppId(key, appId)
    frame_dig -1
    callsub appendAppId
    retsub


// smart_contracts/escreg/contract.algo.ts::Escreg.registerList(appIds: bytes) -> void:
registerList:
    // smart_contracts/escreg/contract.algo.ts:61
    // public registerList(appIds: uint64[]): void {
    proto 1 0
    intc_0 // 0
    // smart_contracts/escreg/contract.algo.ts:62
    // for (const appId of appIds) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    intc_0 // 0

registerList_for_header@1:
    // smart_contracts/escreg/contract.algo.ts:62
    // for (const appId of appIds) {
    frame_dig 2
    frame_dig 1
    <
    bz registerList_after_for@7
    frame_dig -1
    extract 2 0
    frame_dig 2
    intc_3 // 8
    *
    extract_uint64
    dup
    // smart_contracts/escreg/contract.algo.ts:63
    // const key = this.deriveAddrPrefix(appId)
    callsub deriveAddrPrefix
    dup
    frame_bury 0
    // smart_contracts/escreg/contract.algo.ts:64
    // if (!this.apps(key).exists) {
    box_len
    bury 1
    bnz registerList_else_body@4
    // smart_contracts/escreg/contract.algo.ts:65
    // ensureBudget(77, OpUpFeeSource.AppAccount)
    pushint 77 // 77
    intc_2 // 1
    callsub ensure_budget
    // smart_contracts/escreg/contract.algo.ts:66
    // this.apps(key).value = [appId]
    itob
    bytec_1 // 0x0001
    swap
    concat
    frame_dig 0
    dup
    box_del
    pop
    swap
    box_put

registerList_after_if_else@5:
    frame_dig 2
    intc_2 // 1
    +
    frame_bury 2
    b registerList_for_header@1

registerList_else_body@4:
    // smart_contracts/escreg/contract.algo.ts:68
    // ensureBudget(131, OpUpFeeSource.AppAccount)
    pushint 131 // 131
    intc_2 // 1
    callsub ensure_budget
    // smart_contracts/escreg/contract.algo.ts:69
    // this.appendAppId(key, appId)
    frame_dig 0
    swap
    callsub appendAppId
    b registerList_after_if_else@5

registerList_after_for@7:
    retsub


// smart_contracts/escreg/contract.algo.ts::Escreg.deriveAddrPrefix(appId: uint64) -> bytes:
deriveAddrPrefix:
    // smart_contracts/escreg/contract.algo.ts:74
    // private deriveAddrPrefix(appId: uint64): bytes<4> {
    proto 1 1
    // smart_contracts/escreg/contract.algo.ts:75
    // return sha512_256(Bytes`appID`.concat(op.itob(appId)))
    frame_dig -1
    itob
    bytec 6 // "appID"
    swap
    concat
    sha512_256
    // smart_contracts/escreg/contract.algo.ts:75-76
    // return sha512_256(Bytes`appID`.concat(op.itob(appId)))
    //   .slice(0, 4)
    substring 0 4
    // smart_contracts/escreg/contract.algo.ts:75-77
    // return sha512_256(Bytes`appID`.concat(op.itob(appId)))
    //   .slice(0, 4)
    //   .toFixed({ length: 4 })
    dup
    len
    intc_1 // 4
    ==
    assert // Length must be 4
    retsub


// smart_contracts/escreg/contract.algo.ts::Escreg.appendAppId(key: bytes, appId: uint64) -> void:
appendAppId:
    // smart_contracts/escreg/contract.algo.ts:84
    // private appendAppId(key: bytes<4>, appId: uint64) {
    proto 2 0
    // smart_contracts/escreg/contract.algo.ts:85
    // const existing = this.apps(key).value as Readonly<uint64[]>
    frame_dig -2
    box_get
    assert // Box must have value
    // smart_contracts/escreg/contract.algo.ts:85-86
    // const existing = this.apps(key).value as Readonly<uint64[]>
    // for (const existingId of existing) {
    frame_dig -2
    intc_0 // 0
    pushint 2 // 2
    box_extract
    btoi
    intc_0 // 0

appendAppId_for_header@1:
    // smart_contracts/escreg/contract.algo.ts:86
    // for (const existingId of existing) {
    frame_dig 2
    frame_dig 1
    <
    bz appendAppId_after_for@6
    // smart_contracts/escreg/contract.algo.ts:85-86
    // const existing = this.apps(key).value as Readonly<uint64[]>
    // for (const existingId of existing) {
    frame_dig 2
    intc_3 // 8
    *
    pushint 2 // 2
    +
    frame_dig -2
    swap
    intc_3 // 8
    box_extract
    // smart_contracts/escreg/contract.algo.ts:86
    // for (const existingId of existing) {
    btoi
    // smart_contracts/escreg/contract.algo.ts:87
    // if (existingId === appId) {
    frame_dig -1
    ==
    bz appendAppId_after_if_else@4
    // smart_contracts/escreg/contract.algo.ts:88
    // return
    retsub

appendAppId_after_if_else@4:
    frame_dig 2
    intc_2 // 1
    +
    frame_bury 2
    b appendAppId_for_header@1

appendAppId_after_for@6:
    // smart_contracts/escreg/contract.algo.ts:91
    // this.apps(key).value = [...existing, appId]
    frame_dig -1
    itob
    bytec_1 // 0x0001
    swap
    concat
    extract 2 0
    frame_dig 0
    swap
    concat // on error: max array length exceeded
    dup
    extract 2 0
    len
    intc_3 // 8
    /
    itob
    extract 6 2
    replace2 0
    frame_dig -2
    box_del
    pop
    frame_dig -2
    swap
    box_put
    retsub


// smart_contracts/escreg/contract.algo.ts::Escreg.findMatch(address: bytes, apps: bytes) -> uint64:
findMatch:
    // smart_contracts/escreg/contract.algo.ts:94
    // private findMatch(address: Address, apps: Readonly<uint64[]>): uint64 {
    proto 2 1
    bytec_3 // ""
    // smart_contracts/escreg/contract.algo.ts:95
    // for (let i: uint64 = 0; i < apps.length; i++) {
    intc_0 // 0

findMatch_while_top@1:
    // smart_contracts/escreg/contract.algo.ts:95
    // for (let i: uint64 = 0; i < apps.length; i++) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_dig 1
    >
    bz findMatch_after_while@5
    // smart_contracts/escreg/contract.algo.ts:96
    // if (address.native.bytes === this.deriveAddr(apps[i])) {
    frame_dig -1
    extract 2 0
    frame_dig 1
    intc_3 // 8
    *
    extract_uint64
    dup
    frame_bury 0
    // smart_contracts/escreg/contract.algo.ts:81
    // return sha512_256(Bytes`appID`.concat(op.itob(appId)))
    itob
    bytec 6 // "appID"
    swap
    concat
    sha512_256
    // smart_contracts/escreg/contract.algo.ts:96
    // if (address.native.bytes === this.deriveAddr(apps[i])) {
    frame_dig -2
    ==
    bz findMatch_after_if_else@4
    // smart_contracts/escreg/contract.algo.ts:97
    // return apps[i]
    retsub

findMatch_after_if_else@4:
    // smart_contracts/escreg/contract.algo.ts:95
    // for (let i: uint64 = 0; i < apps.length; i++) {
    frame_dig 1
    intc_2 // 1
    +
    frame_bury 1
    b findMatch_while_top@1

findMatch_after_while@5:
    // smart_contracts/escreg/contract.algo.ts:100
    // return 0
    intc_0 // 0
    frame_bury 0
    retsub


// smart_contracts/escreg/contract.algo.ts::Escreg.exists(address: bytes) -> uint64:
exists:
    // smart_contracts/escreg/contract.algo.ts:103-104
    // @abimethod({ readonly: true })
    // public exists(address: Address): boolean {
    proto 1 1
    // smart_contracts/escreg/contract.algo.ts:105
    // const addr4 = address.bytes.slice(0, 4).toFixed({ length: 4 })
    frame_dig -1
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_1 // 4
    dig 2
    >=
    intc_1 // 4
    uncover 3
    uncover 2
    select
    frame_dig -1
    cover 2
    substring3
    dupn 2
    len
    intc_1 // 4
    ==
    assert // Length must be 4
    // smart_contracts/escreg/contract.algo.ts:107
    // if (!this.apps(addr4).exists) {
    box_len
    bury 1
    bnz exists_after_if_else@2
    // smart_contracts/escreg/contract.algo.ts:108
    // return false
    intc_0 // 0
    swap
    retsub

exists_after_if_else@2:
    // smart_contracts/escreg/contract.algo.ts:111
    // const apps = this.apps(addr4).value as Readonly<uint64[]>
    frame_dig 0
    box_get
    assert // Box must have value
    // smart_contracts/escreg/contract.algo.ts:112
    // const matchingAppID = this.findMatch(address, apps)
    frame_dig -1
    swap
    callsub findMatch
    // smart_contracts/escreg/contract.algo.ts:114
    // return matchingAppID !== 0
    intc_0 // 0
    !=
    swap
    retsub


// smart_contracts/escreg/contract.algo.ts::Escreg.get(address: bytes) -> uint64:
get:
    // smart_contracts/escreg/contract.algo.ts:117-118
    // @abimethod({ readonly: true })
    // public get(address: Address): uint64 {
    proto 1 1
    // smart_contracts/escreg/contract.algo.ts:119
    // const addr4 = address.bytes.slice(0, 4).toFixed({ length: 4 })
    frame_dig -1
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_1 // 4
    dig 2
    >=
    intc_1 // 4
    uncover 3
    uncover 2
    select
    frame_dig -1
    cover 2
    substring3
    dupn 2
    len
    intc_1 // 4
    ==
    assert // Length must be 4
    // smart_contracts/escreg/contract.algo.ts:121
    // if (!this.apps(addr4).exists) {
    box_len
    bury 1
    bnz get_after_if_else@2
    // smart_contracts/escreg/contract.algo.ts:122
    // return 0
    intc_0 // 0
    swap
    retsub

get_after_if_else@2:
    // smart_contracts/escreg/contract.algo.ts:125
    // const apps = this.apps(addr4).value as Readonly<uint64[]>
    frame_dig 0
    box_get
    assert // Box must have value
    // smart_contracts/escreg/contract.algo.ts:126
    // const matchingAppID = this.findMatch(address, apps)
    frame_dig -1
    swap
    callsub findMatch
    // smart_contracts/escreg/contract.algo.ts:128
    // return matchingAppID
    swap
    retsub


// smart_contracts/escreg/contract.algo.ts::Escreg.mustGet(address: bytes) -> uint64:
mustGet:
    // smart_contracts/escreg/contract.algo.ts:131-132
    // @abimethod({ readonly: true })
    // public mustGet(address: Address): uint64 {
    proto 1 1
    // smart_contracts/escreg/contract.algo.ts:133
    // const addr4 = address.bytes.slice(0, 4).toFixed({ length: 4 })
    frame_dig -1
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_1 // 4
    dig 2
    >=
    intc_1 // 4
    uncover 3
    uncover 2
    select
    frame_dig -1
    cover 2
    substring3
    dup
    len
    intc_1 // 4
    ==
    assert // Length must be 4
    // smart_contracts/escreg/contract.algo.ts:135
    // assert(this.apps(addr4).exists, ERR_APP_NOT_REGISTERED)
    dup
    box_len
    bury 1
    assert // ERR:NOTFOUND
    // smart_contracts/escreg/contract.algo.ts:137
    // const apps = this.apps(addr4).value as Readonly<uint64[]>
    box_get
    pop
    // smart_contracts/escreg/contract.algo.ts:138
    // const matchingAppID = this.findMatch(address, apps)
    frame_dig -1
    swap
    callsub findMatch
    // smart_contracts/escreg/contract.algo.ts:140
    // assert(matchingAppID !== 0, ERR_APP_NOT_REGISTERED)
    dup
    assert // ERR:NOTFOUND
    // smart_contracts/escreg/contract.algo.ts:142
    // return matchingAppID
    retsub


// smart_contracts/escreg/contract.algo.ts::Escreg.getWithAuth(address: bytes) -> bytes:
getWithAuth:
    // smart_contracts/escreg/contract.algo.ts:145-146
    // @abimethod({ readonly: true })
    // public getWithAuth(address: Address): AddressWithAuth {
    proto 1 1
    intc_0 // 0
    dup
    bytec_3 // ""
    // smart_contracts/escreg/contract.algo.ts:147
    // const addr4 = address.bytes.slice(0, 4).toFixed({ length: 4 })
    frame_dig -1
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_1 // 4
    dig 2
    >=
    intc_1 // 4
    uncover 3
    uncover 2
    select
    frame_dig -1
    cover 2
    substring3
    dupn 2
    len
    intc_1 // 4
    ==
    assert // Length must be 4
    // smart_contracts/escreg/contract.algo.ts:149
    // let appId: uint64 = 0
    intc_0 // 0
    swap
    // smart_contracts/escreg/contract.algo.ts:150
    // if (this.apps(addr4).exists) {
    box_len
    bury 1
    bz getWithAuth_after_if_else@2
    // smart_contracts/escreg/contract.algo.ts:151
    // const apps = this.apps(addr4).value as Readonly<uint64[]>
    frame_dig 3
    box_get
    assert // Box must have value
    // smart_contracts/escreg/contract.algo.ts:152
    // appId = this.findMatch(address, apps)
    frame_dig -1
    swap
    callsub findMatch
    frame_bury 4

getWithAuth_after_if_else@2:
    // smart_contracts/escreg/contract.algo.ts:155
    // const authAddr = address.native.authAddress
    frame_dig -1
    acct_params_get AcctAuthAddr
    swap
    dup
    cover 2
    frame_bury 0
    assert // account funded
    // smart_contracts/escreg/contract.algo.ts:156
    // const authAddr4 = authAddr.bytes.slice(0, 4).toFixed({ length: 4 })
    dup
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_1 // 4
    dig 2
    >=
    intc_1 // 4
    uncover 3
    uncover 2
    select
    substring3
    dup
    frame_bury 1
    dup
    len
    intc_1 // 4
    ==
    assert // Length must be 4
    // smart_contracts/escreg/contract.algo.ts:158
    // let authAppId: uint64 = 0
    intc_0 // 0
    frame_bury 2
    // smart_contracts/escreg/contract.algo.ts:159
    // if (this.apps(authAddr4).exists) {
    box_len
    bury 1
    bz getWithAuth_after_if_else@4
    // smart_contracts/escreg/contract.algo.ts:160
    // const apps = this.apps(authAddr4).value as Readonly<uint64[]>
    frame_dig 1
    box_get
    assert // Box must have value
    // smart_contracts/escreg/contract.algo.ts:161
    // authAppId = this.findMatch(new Address(authAddr), apps)
    frame_dig 0
    swap
    callsub findMatch
    frame_bury 2

getWithAuth_after_if_else@4:
    // smart_contracts/escreg/contract.algo.ts:164
    // return { appId, authAppId }
    frame_dig 4
    itob
    frame_dig 2
    itob
    concat
    frame_bury 0
    retsub


// smart_contracts/escreg/contract.algo.ts::Escreg.getWithAuthList(addresses: bytes) -> bytes:
getWithAuthList:
    // smart_contracts/escreg/contract.algo.ts:167-168
    // @abimethod({ readonly: true })
    // public getWithAuthList(addresses: Address[]): AddressWithAuth[] {
    proto 1 1
    intc_0 // 0
    dupn 3
    bytec_3 // ""
    dup
    // smart_contracts/escreg/contract.algo.ts:169
    // let results: AddressWithAuth[] = []
    bytec 4 // 0x0000
    // smart_contracts/escreg/contract.algo.ts:171
    // for (const address of addresses) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    intc_0 // 0

getWithAuthList_for_header@1:
    // smart_contracts/escreg/contract.algo.ts:171
    // for (const address of addresses) {
    frame_dig 8
    frame_dig 7
    <
    bz getWithAuthList_after_for@8
    frame_dig -1
    extract 2 0
    frame_dig 8
    pushint 32 // 32
    *
    pushint 32 // 32
    extract3 // on error: index access is out of bounds
    dup
    frame_bury 3
    // smart_contracts/escreg/contract.algo.ts:172
    // const addr4 = address.bytes.slice(0, 4).toFixed({ length: 4 })
    dup
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_1 // 4
    dig 2
    >=
    intc_1 // 4
    uncover 3
    uncover 2
    select
    substring3
    dup
    frame_bury 0
    dup
    len
    intc_1 // 4
    ==
    assert // Length must be 4
    // smart_contracts/escreg/contract.algo.ts:174
    // let appId: uint64 = 0
    intc_0 // 0
    frame_bury 4
    // smart_contracts/escreg/contract.algo.ts:175
    // if (this.apps(addr4).exists) {
    box_len
    bury 1
    bz getWithAuthList_after_if_else@4
    // smart_contracts/escreg/contract.algo.ts:176
    // const apps = this.apps(addr4).value as Readonly<uint64[]>
    frame_dig 0
    box_get
    assert // Box must have value
    // smart_contracts/escreg/contract.algo.ts:177
    // appId = this.findMatch(address, apps)
    frame_dig 3
    swap
    callsub findMatch
    frame_bury 4

getWithAuthList_after_if_else@4:
    // smart_contracts/escreg/contract.algo.ts:180
    // const authAddr = address.native.authAddress
    frame_dig 3
    acct_params_get AcctAuthAddr
    swap
    dup
    cover 2
    frame_bury 1
    assert // account funded
    // smart_contracts/escreg/contract.algo.ts:181
    // const authAddr4 = authAddr.bytes.slice(0, 4).toFixed({ length: 4 })
    dup
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_1 // 4
    dig 2
    >=
    intc_1 // 4
    uncover 3
    uncover 2
    select
    substring3
    dup
    frame_bury 2
    dup
    len
    intc_1 // 4
    ==
    assert // Length must be 4
    // smart_contracts/escreg/contract.algo.ts:183
    // let authAppId: uint64 = 0
    intc_0 // 0
    frame_bury 5
    // smart_contracts/escreg/contract.algo.ts:184
    // if (this.apps(authAddr4).exists) {
    box_len
    bury 1
    bz getWithAuthList_after_if_else@6
    // smart_contracts/escreg/contract.algo.ts:185
    // const apps = this.apps(authAddr4).value as Readonly<uint64[]>
    frame_dig 2
    box_get
    assert // Box must have value
    // smart_contracts/escreg/contract.algo.ts:186
    // authAppId = this.findMatch(new Address(authAddr), apps)
    frame_dig 1
    swap
    callsub findMatch
    frame_bury 5

getWithAuthList_after_if_else@6:
    // smart_contracts/escreg/contract.algo.ts:189
    // results.push({ appId, authAppId })
    frame_dig 4
    itob
    frame_dig 5
    itob
    concat
    frame_dig 6
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_2 // 1
    +
    itob
    extract 6 2
    replace2 0
    frame_bury 6
    frame_dig 8
    intc_2 // 1
    +
    frame_bury 8
    b getWithAuthList_for_header@1

getWithAuthList_after_for@8:
    // smart_contracts/escreg/contract.algo.ts:192
    // return results
    frame_dig 6
    frame_bury 0
    retsub


// smart_contracts/escreg/contract.algo.ts::Escreg.getList(addresses: bytes) -> bytes:
getList:
    // smart_contracts/escreg/contract.algo.ts:195-196
    // @abimethod({ readonly: true })
    // public getList(addresses: Address[]): uint64[] {
    proto 1 1
    intc_0 // 0
    dup
    // smart_contracts/escreg/contract.algo.ts:197
    // let apps: uint64[] = []
    bytec 4 // 0x0000
    // smart_contracts/escreg/contract.algo.ts:200
    // ensureBudget(200 * addresses.length)
    frame_dig -1
    intc_0 // 0
    extract_uint16
    dup
    pushint 200 // 200
    *
    intc_0 // 0
    callsub ensure_budget
    intc_0 // 0

getList_for_header@1:
    // smart_contracts/escreg/contract.algo.ts:202
    // for (const address of addresses) {
    frame_dig 4
    frame_dig 3
    <
    bz getList_after_for@7
    frame_dig -1
    extract 2 0
    frame_dig 4
    pushint 32 // 32
    *
    pushint 32 // 32
    extract3 // on error: index access is out of bounds
    dup
    frame_bury 1
    // smart_contracts/escreg/contract.algo.ts:203
    // const addr4 = address.bytes.slice(0, 4).toFixed({ length: 4 })
    dup
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_1 // 4
    dig 2
    >=
    intc_1 // 4
    uncover 3
    uncover 2
    select
    substring3
    dup
    frame_bury 0
    dup
    len
    intc_1 // 4
    ==
    assert // Length must be 4
    // smart_contracts/escreg/contract.algo.ts:205
    // if (!this.apps(addr4).exists) {
    box_len
    bury 1
    bnz getList_after_if_else@4
    // smart_contracts/escreg/contract.algo.ts:206
    // apps = [...apps, zero]
    frame_dig 2
    pushbytes 0x0000000000000000
    concat // on error: max array length exceeded
    dup
    extract 2 0
    len
    intc_3 // 8
    /
    itob
    extract 6 2
    replace2 0
    frame_bury 2

getList_block@5:
    frame_dig 4
    intc_2 // 1
    +
    frame_bury 4
    b getList_for_header@1

getList_after_if_else@4:
    // smart_contracts/escreg/contract.algo.ts:210
    // const appList = this.apps(addr4).value as Readonly<uint64[]>
    frame_dig 0
    box_get
    assert // Box must have value
    // smart_contracts/escreg/contract.algo.ts:211
    // apps = [...apps, this.findMatch(address, appList)]
    frame_dig 1
    swap
    callsub findMatch
    itob
    bytec_1 // 0x0001
    swap
    concat
    extract 2 0
    frame_dig 2
    swap
    concat // on error: max array length exceeded
    dup
    extract 2 0
    len
    intc_3 // 8
    /
    itob
    extract 6 2
    replace2 0
    frame_bury 2
    b getList_block@5

getList_after_for@7:
    // smart_contracts/escreg/contract.algo.ts:213
    // return apps
    frame_dig 2
    frame_bury 0
    retsub


// smart_contracts/escreg/contract.algo.ts::Escreg.mustGetList(addresses: bytes) -> bytes:
mustGetList:
    // smart_contracts/escreg/contract.algo.ts:216-217
    // @abimethod({ readonly: true })
    // public mustGetList(addresses: Address[]): uint64[] {
    proto 1 1
    // smart_contracts/escreg/contract.algo.ts:218
    // let apps: uint64[] = []
    bytec 4 // 0x0000
    // smart_contracts/escreg/contract.algo.ts:219
    // for (const address of addresses) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    intc_0 // 0

mustGetList_for_header@1:
    // smart_contracts/escreg/contract.algo.ts:219
    // for (const address of addresses) {
    frame_dig 2
    frame_dig 1
    <
    bz mustGetList_after_for@6
    frame_dig -1
    extract 2 0
    frame_dig 2
    dup
    cover 2
    pushint 32 // 32
    *
    pushint 32 // 32
    extract3 // on error: index access is out of bounds
    // smart_contracts/escreg/contract.algo.ts:220
    // const addr4 = address.bytes.slice(0, 4).toFixed({ length: 4 })
    dup
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_1 // 4
    dig 2
    >=
    intc_1 // 4
    uncover 3
    uncover 2
    select
    dig 2
    cover 2
    substring3
    dup
    len
    intc_1 // 4
    ==
    assert // Length must be 4
    // smart_contracts/escreg/contract.algo.ts:222
    // if (!this.apps(addr4).exists) {
    dup
    box_len
    bury 1
    assert // ERR:NOTFOUND
    // smart_contracts/escreg/contract.algo.ts:226
    // const appList = this.apps(addr4).value as Readonly<uint64[]>
    box_get
    pop
    // smart_contracts/escreg/contract.algo.ts:227
    // const matchingAppID = this.findMatch(address, appList)
    callsub findMatch
    // smart_contracts/escreg/contract.algo.ts:229
    // assert(matchingAppID !== 0, ERR_APP_NOT_REGISTERED)
    dup
    assert // ERR:NOTFOUND
    // smart_contracts/escreg/contract.algo.ts:230
    // apps = [...apps, matchingAppID]
    itob
    bytec_1 // 0x0001
    swap
    concat
    extract 2 0
    frame_dig 0
    swap
    concat // on error: max array length exceeded
    dup
    extract 2 0
    len
    intc_3 // 8
    /
    itob
    extract 6 2
    replace2 0
    frame_bury 0
    intc_2 // 1
    +
    frame_bury 2
    b mustGetList_for_header@1

mustGetList_after_for@6:
    // smart_contracts/escreg/contract.algo.ts:232
    // return apps
    retsub
