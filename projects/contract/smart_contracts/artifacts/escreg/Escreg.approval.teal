#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 4 8
    bytecblock "c" "counter" 0x151f7c75 "" 0x0001 "ERR:404" 0x0000 "admin" 0x0a8101 "ERR:RCV" "ERR:AMT" "appID"
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/escreg/contract.algo.ts:28
    // admin = GlobalState<Address>({ initialValue: new Address(Txn.sender) })
    bytec 7 // "admin"
    txn Sender
    app_global_put
    // smart_contracts/escreg/contract.algo.ts:32
    // counter = GlobalState<uint64>({ initialValue: 0 })
    bytec_1 // "counter"
    intc_0 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/escreg/contract.algo.ts:26
    // export class Escreg extends MbrManager implements ConventionalRouting {
    txn NumAppArgs
    bz main___algots__.defaultCreate@26
    pushbytess 0x2487c32c 0x46f76533 // method "deleteApplication()void", method "updateApplication()void"
    txna ApplicationArgs 0
    match main_deleteApplication_route@5 main_updateApplication_route@6

main_switch_case_next@7:
    // smart_contracts/escreg/contract.algo.ts:26
    // export class Escreg extends MbrManager implements ConventionalRouting {
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0x21f1ddff 0xf3e8bae3 0xf7e99a83 0x72bf6dc4 0x4c9fb656 0x89e79924 0x40e65262 0x193625f8 0x90c9550f 0xb561c256 0x82b435f8 0x4118ecbf 0x3d75f0c4 0xeaee7fbd // method "withdraw(uint64)void", method "deleteBoxes(byte[4][])void", method "register(uint64)void", method "registerList(uint64[])void", method "exists(address)bool", method "get(address)uint64", method "mustGet(address)uint64", method "getWithAuth(address)(uint64,uint64)", method "getWithAuthList(address[])(uint64,uint64)[]", method "getList(address[])uint64[]", method "mustGetList(address[])uint64[]", method "increaseBudget(uint64)void", method "depositCredits(address,pay)void", method "withdrawCredits()void"
    txna ApplicationArgs 0
    match withdraw deleteBoxes register registerList exists get mustGet getWithAuth getWithAuthList getList mustGetList increaseBudget depositCredits withdrawCredits
    err

main_updateApplication_route@6:
    // smart_contracts/escreg/contract.algo.ts:51
    // @abimethod({ validateEncoding: 'unsafe-disabled' })
    txn OnCompletion
    intc_2 // UpdateApplication
    ==
    txn ApplicationID
    &&
    assert // OnCompletion must be UpdateApplication && can only call when not creating
    b updateApplication

main_deleteApplication_route@5:
    // smart_contracts/escreg/contract.algo.ts:42
    // @abimethod({ validateEncoding: 'unsafe-disabled' })
    txn OnCompletion
    pushint 5 // DeleteApplication
    ==
    txn ApplicationID
    &&
    assert // OnCompletion must be DeleteApplication && can only call when not creating
    b deleteApplication

main___algots__.defaultCreate@26:
    // smart_contracts/escreg/contract.algo.ts:26
    // export class Escreg extends MbrManager implements ConventionalRouting {
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    assert // OnCompletion must be NoOp && can only call when creating
    intc_1 // 1
    return


// smart_contracts/escreg/contract.algo.ts::Escreg.deleteApplication[routing]() -> void:
deleteApplication:
    // smart_contracts/escreg/contract.algo.ts:44
    // this.adminOnly()
    callsub adminOnly
    // smart_contracts/escreg/contract.algo.ts:42
    // @abimethod({ validateEncoding: 'unsafe-disabled' })
    intc_1 // 1
    return


// smart_contracts/escreg/contract.algo.ts::Escreg.updateApplication[routing]() -> void:
updateApplication:
    // smart_contracts/escreg/contract.algo.ts:53
    // this.adminOnly()
    callsub adminOnly
    // smart_contracts/escreg/contract.algo.ts:51
    // @abimethod({ validateEncoding: 'unsafe-disabled' })
    intc_1 // 1
    return


// smart_contracts/escreg/contract.algo.ts::Escreg.withdraw[routing]() -> void:
withdraw:
    // smart_contracts/escreg/contract.algo.ts:61
    // @abimethod({ validateEncoding: 'unsafe-disabled' })
    txna ApplicationArgs 1
    btoi
    // smart_contracts/escreg/contract.algo.ts:63
    // this.adminOnly()
    callsub adminOnly
    // smart_contracts/escreg/contract.algo.ts:64-69
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/escreg/contract.algo.ts:66
    // receiver: Txn.sender,
    txn Sender
    itxn_field Receiver
    itxn_field Amount
    // smart_contracts/escreg/contract.algo.ts:64-68
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/escreg/contract.algo.ts:64-69
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/escreg/contract.algo.ts:61
    // @abimethod({ validateEncoding: 'unsafe-disabled' })
    intc_1 // 1
    return


// smart_contracts/escreg/contract.algo.ts::Escreg.deleteBoxes[routing]() -> void:
deleteBoxes:
    // smart_contracts/escreg/contract.algo.ts:77
    // @abimethod({ validateEncoding: 'unsafe-disabled' })
    txna ApplicationArgs 1
    dup
    // smart_contracts/escreg/contract.algo.ts:79
    // this.adminOnly()
    callsub adminOnly
    // smart_contracts/escreg/contract.algo.ts:80
    // for (const key of boxKeys) {
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 0

deleteBoxes_for_header@2:
    // smart_contracts/escreg/contract.algo.ts:80
    // for (const key of boxKeys) {
    dup
    dig 2
    <
    bz deleteBoxes_after_for@5
    dig 2
    extract 2 0
    dig 1
    dup
    cover 2
    intc_2 // 4
    *
    intc_2 // 4
    extract3 // on error: index access is out of bounds
    // smart_contracts/escreg/contract.algo.ts:81
    // this.apps(key).delete()
    box_del
    pop
    intc_1 // 1
    +
    bury 1
    b deleteBoxes_for_header@2

deleteBoxes_after_for@5:
    // smart_contracts/escreg/contract.algo.ts:77
    // @abimethod({ validateEncoding: 'unsafe-disabled' })
    intc_1 // 1
    return


// smart_contracts/escreg/contract.algo.ts::Escreg.register[routing]() -> void:
register:
    // smart_contracts/escreg/contract.algo.ts:99
    // @abimethod({ validateEncoding: 'unsafe-disabled' })
    txna ApplicationArgs 1
    btoi
    dup
    // smart_contracts/escreg/contract.algo.ts:101
    // const mbrBefore = Global.currentApplicationAddress.minBalance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    swap
    cover 2
    assert // account funded
    // smart_contracts/escreg/contract.algo.ts:103
    // const key = this.deriveAddrPrefix(appId)
    callsub deriveAddrPrefix
    dup
    // smart_contracts/escreg/contract.algo.ts:104
    // if (!this.apps(key).exists) {
    box_len
    bury 1
    bnz register_else_body@3
    // smart_contracts/escreg/contract.algo.ts:105
    // this.counter.value += 1
    intc_0 // 0
    // smart_contracts/escreg/contract.algo.ts:32
    // counter = GlobalState<uint64>({ initialValue: 0 })
    bytec_1 // "counter"
    // smart_contracts/escreg/contract.algo.ts:105
    // this.counter.value += 1
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    +
    // smart_contracts/escreg/contract.algo.ts:32
    // counter = GlobalState<uint64>({ initialValue: 0 })
    bytec_1 // "counter"
    // smart_contracts/escreg/contract.algo.ts:105
    // this.counter.value += 1
    swap
    app_global_put
    // smart_contracts/escreg/contract.algo.ts:106
    // this.apps(key).value = [appId]
    dig 2
    itob
    bytec 4 // 0x0001
    swap
    concat
    swap
    dup
    box_del
    pop
    swap
    box_put

register_after_if_else@4:
    // smart_contracts/escreg/contract.algo.ts:111
    // this.manageMbrCredits(mbrBefore)
    dup
    callsub manageMbrCredits
    // smart_contracts/escreg/contract.algo.ts:99
    // @abimethod({ validateEncoding: 'unsafe-disabled' })
    intc_1 // 1
    return

register_else_body@3:
    // smart_contracts/escreg/contract.algo.ts:108
    // this.appendAppId(key, appId)
    dig 2
    callsub appendAppId
    b register_after_if_else@4


// smart_contracts/escreg/contract.algo.ts::Escreg.registerList[routing]() -> void:
registerList:
    intc_0 // 0
    // smart_contracts/escreg/contract.algo.ts:119
    // @abimethod({ validateEncoding: 'unsafe-disabled' })
    txna ApplicationArgs 1
    dup
    // smart_contracts/escreg/contract.algo.ts:121
    // const mbrBefore = Global.currentApplicationAddress.minBalance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    swap
    cover 2
    assert // account funded
    // smart_contracts/escreg/contract.algo.ts:123
    // for (const appId of appIds) {
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 0

registerList_for_header@2:
    // smart_contracts/escreg/contract.algo.ts:123
    // for (const appId of appIds) {
    dup
    dig 2
    <
    bz registerList_after_for@8
    dig 3
    extract 2 0
    dig 1
    intc_3 // 8
    *
    extract_uint64
    dup
    // smart_contracts/escreg/contract.algo.ts:124
    // const key = this.deriveAddrPrefix(appId)
    callsub deriveAddrPrefix
    dup
    bury 7
    // smart_contracts/escreg/contract.algo.ts:125
    // if (!this.apps(key).exists) {
    box_len
    bury 1
    bnz registerList_else_body@5
    // smart_contracts/escreg/contract.algo.ts:126
    // this.counter.value += 1
    intc_0 // 0
    // smart_contracts/escreg/contract.algo.ts:32
    // counter = GlobalState<uint64>({ initialValue: 0 })
    bytec_1 // "counter"
    // smart_contracts/escreg/contract.algo.ts:126
    // this.counter.value += 1
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    +
    // smart_contracts/escreg/contract.algo.ts:32
    // counter = GlobalState<uint64>({ initialValue: 0 })
    bytec_1 // "counter"
    // smart_contracts/escreg/contract.algo.ts:126
    // this.counter.value += 1
    swap
    app_global_put
    // smart_contracts/escreg/contract.algo.ts:127
    // this.apps(key).value = [appId]
    itob
    bytec 4 // 0x0001
    swap
    concat
    dig 5
    dup
    box_del
    pop
    swap
    box_put

registerList_after_if_else@6:
    dup
    intc_1 // 1
    +
    bury 1
    b registerList_for_header@2

registerList_else_body@5:
    // smart_contracts/escreg/contract.algo.ts:129
    // this.appendAppId(key, appId)
    dig 5
    swap
    callsub appendAppId
    b registerList_after_if_else@6

registerList_after_for@8:
    // smart_contracts/escreg/contract.algo.ts:133
    // this.manageMbrCredits(mbrBefore)
    dig 2
    callsub manageMbrCredits
    // smart_contracts/escreg/contract.algo.ts:119
    // @abimethod({ validateEncoding: 'unsafe-disabled' })
    intc_1 // 1
    return


// smart_contracts/escreg/contract.algo.ts::Escreg.exists[routing]() -> void:
exists:
    // smart_contracts/escreg/contract.algo.ts:192
    // @abimethod({ readonly: true, validateEncoding: 'unsafe-disabled' })
    txna ApplicationArgs 1
    dupn 2
    // smart_contracts/escreg/contract.algo.ts:194
    // const addr4 = address.bytes.slice(0, 4).toFixed({ strategy: 'unsafe-cast', length: 4 })
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_2 // 4
    dig 2
    >=
    intc_2 // 4
    uncover 3
    uncover 2
    select
    substring3
    dup
    // smart_contracts/escreg/contract.algo.ts:196
    // if (!this.apps(addr4).exists) {
    box_len
    bury 1
    bnz exists_after_if_else@3
    // smart_contracts/escreg/contract.algo.ts:197
    // return false
    intc_0 // 0

exists_after_inlined_smart_contracts/escreg/contract.algo.ts::Escreg.exists@4:
    // smart_contracts/escreg/contract.algo.ts:192
    // @abimethod({ readonly: true, validateEncoding: 'unsafe-disabled' })
    pushbytes 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

exists_after_if_else@3:
    // smart_contracts/escreg/contract.algo.ts:200
    // const apps = this.apps(addr4).value as Readonly<uint64[]>
    dup
    box_get
    assert // Box must have value
    // smart_contracts/escreg/contract.algo.ts:201
    // const matchingAppID = this.findAddr(address, apps)
    dig 2
    swap
    callsub findAddr
    // smart_contracts/escreg/contract.algo.ts:203
    // return matchingAppID !== 0
    intc_0 // 0
    !=
    // smart_contracts/escreg/contract.algo.ts:192
    // @abimethod({ readonly: true, validateEncoding: 'unsafe-disabled' })
    b exists_after_inlined_smart_contracts/escreg/contract.algo.ts::Escreg.exists@4


// smart_contracts/escreg/contract.algo.ts::Escreg.get[routing]() -> void:
get:
    // smart_contracts/escreg/contract.algo.ts:211
    // @abimethod({ readonly: true, validateEncoding: 'unsafe-disabled' })
    txna ApplicationArgs 1
    dupn 2
    // smart_contracts/escreg/contract.algo.ts:213
    // const addr4 = address.bytes.slice(0, 4).toFixed({ strategy: 'unsafe-cast', length: 4 })
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_2 // 4
    dig 2
    >=
    intc_2 // 4
    uncover 3
    uncover 2
    select
    substring3
    dup
    // smart_contracts/escreg/contract.algo.ts:215
    // if (!this.apps(addr4).exists) {
    box_len
    bury 1
    bnz get_after_if_else@3
    // smart_contracts/escreg/contract.algo.ts:216
    // return 0
    intc_0 // 0

get_after_inlined_smart_contracts/escreg/contract.algo.ts::Escreg.get@4:
    // smart_contracts/escreg/contract.algo.ts:211
    // @abimethod({ readonly: true, validateEncoding: 'unsafe-disabled' })
    itob
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

get_after_if_else@3:
    // smart_contracts/escreg/contract.algo.ts:219
    // const apps = this.apps(addr4).value as Readonly<uint64[]>
    dup
    box_get
    assert // Box must have value
    // smart_contracts/escreg/contract.algo.ts:220
    // const matchingAppID = this.findAddr(address, apps)
    dig 2
    swap
    callsub findAddr
    // smart_contracts/escreg/contract.algo.ts:211
    // @abimethod({ readonly: true, validateEncoding: 'unsafe-disabled' })
    b get_after_inlined_smart_contracts/escreg/contract.algo.ts::Escreg.get@4


// smart_contracts/escreg/contract.algo.ts::Escreg.mustGet[routing]() -> void:
mustGet:
    bytec_3 // ""
    // smart_contracts/escreg/contract.algo.ts:231
    // @abimethod({ readonly: true, validateEncoding: 'unsafe-disabled' })
    txna ApplicationArgs 1
    dupn 2
    // smart_contracts/escreg/contract.algo.ts:233
    // const addr4 = address.bytes.slice(0, 4).toFixed({ strategy: 'unsafe-cast', length: 4 })
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_2 // 4
    dig 2
    >=
    intc_2 // 4
    uncover 3
    uncover 2
    select
    substring3
    dup
    // smart_contracts/escreg/contract.algo.ts:235
    // ensure(this.apps(addr4).exists, errAppNotRegistered)
    box_len
    bury 1
    // smart_contracts/common.algo.ts:4
    // if (!condition) {
    bnz mustGet_after_if_else@3
    // smart_contracts/escreg/contract.algo.ts:235
    // ensure(this.apps(addr4).exists, errAppNotRegistered)
    bytec 5 // "ERR:404"
    // smart_contracts/common.algo.ts:5
    // log(message)
    log
    // smart_contracts/common.algo.ts:6
    // err()
    err

mustGet_after_if_else@3:
    // smart_contracts/escreg/contract.algo.ts:237
    // const apps = this.apps(addr4).value as Readonly<uint64[]>
    dup
    box_get
    assert // Box must have value
    // smart_contracts/escreg/contract.algo.ts:238
    // const matchingAppID = this.findAddr(address, apps)
    dig 2
    swap
    callsub findAddr
    dup
    bury 4
    // smart_contracts/common.algo.ts:4
    // if (!condition) {
    bnz mustGet_after_if_else@7
    // smart_contracts/escreg/contract.algo.ts:240
    // ensure(matchingAppID !== 0, errAppNotRegistered)
    bytec 5 // "ERR:404"
    // smart_contracts/common.algo.ts:5
    // log(message)
    log
    // smart_contracts/common.algo.ts:6
    // err()
    err

mustGet_after_if_else@7:
    // smart_contracts/escreg/contract.algo.ts:231
    // @abimethod({ readonly: true, validateEncoding: 'unsafe-disabled' })
    dig 2
    itob
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/escreg/contract.algo.ts::Escreg.getWithAuth[routing]() -> void:
getWithAuth:
    intc_0 // 0
    dup
    bytec_3 // ""
    // smart_contracts/escreg/contract.algo.ts:250
    // @abimethod({ readonly: true, validateEncoding: 'unsafe-disabled' })
    txna ApplicationArgs 1
    dupn 2
    // smart_contracts/escreg/contract.algo.ts:252
    // const addr4 = address.bytes.slice(0, 4).toFixed({ strategy: 'unsafe-cast', length: 4 })
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_2 // 4
    dig 2
    >=
    intc_2 // 4
    uncover 3
    uncover 2
    select
    substring3
    dup
    // smart_contracts/escreg/contract.algo.ts:254
    // let appId: uint64 = 0
    intc_0 // 0
    swap
    // smart_contracts/escreg/contract.algo.ts:255
    // if (this.apps(addr4).exists) {
    box_len
    bury 1
    bz getWithAuth_after_if_else@3
    // smart_contracts/escreg/contract.algo.ts:256
    // const apps = this.apps(addr4).value as Readonly<uint64[]>
    dig 1
    box_get
    assert // Box must have value
    // smart_contracts/escreg/contract.algo.ts:257
    // appId = this.findAddr(address, apps)
    dig 3
    swap
    callsub findAddr
    bury 1

getWithAuth_after_if_else@3:
    // smart_contracts/escreg/contract.algo.ts:260
    // const authAddr = address.native.authAddress
    dig 2
    acct_params_get AcctAuthAddr
    swap
    dup
    cover 2
    bury 8
    assert // account funded
    // smart_contracts/escreg/contract.algo.ts:261
    // const authAddr4 = authAddr.bytes.slice(0, 4).toFixed({ strategy: 'unsafe-cast', length: 4 })
    dup
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_2 // 4
    dig 2
    >=
    intc_2 // 4
    uncover 3
    uncover 2
    select
    substring3
    dup
    bury 6
    // smart_contracts/escreg/contract.algo.ts:263
    // let authAppId: uint64 = 0
    intc_0 // 0
    bury 5
    // smart_contracts/escreg/contract.algo.ts:264
    // if (this.apps(authAddr4).exists) {
    box_len
    bury 1
    bz getWithAuth_after_if_else@5
    // smart_contracts/escreg/contract.algo.ts:265
    // const apps = this.apps(authAddr4).value as Readonly<uint64[]>
    dig 4
    box_get
    assert // Box must have value
    // smart_contracts/escreg/contract.algo.ts:266
    // authAppId = this.findAddr(new Address(authAddr), apps)
    dig 6
    swap
    callsub findAddr
    bury 4

getWithAuth_after_if_else@5:
    // smart_contracts/escreg/contract.algo.ts:269
    // return { appId, authAppId }
    dup
    itob
    dig 4
    itob
    concat
    // smart_contracts/escreg/contract.algo.ts:250
    // @abimethod({ readonly: true, validateEncoding: 'unsafe-disabled' })
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/escreg/contract.algo.ts::Escreg.getWithAuthList[routing]() -> void:
getWithAuthList:
    intc_0 // 0
    dupn 3
    bytec_3 // ""
    dup
    // smart_contracts/escreg/contract.algo.ts:277
    // @abimethod({ readonly: true, validateEncoding: 'unsafe-disabled' })
    txna ApplicationArgs 1
    // smart_contracts/escreg/contract.algo.ts:279
    // let results: AddressWithAuth[] = []
    bytec 6 // 0x0000
    // smart_contracts/escreg/contract.algo.ts:277
    // @abimethod({ readonly: true, validateEncoding: 'unsafe-disabled' })
    txna ApplicationArgs 1
    // smart_contracts/escreg/contract.algo.ts:281
    // for (const address of addresses) {
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 0

getWithAuthList_for_header@2:
    // smart_contracts/escreg/contract.algo.ts:281
    // for (const address of addresses) {
    dup
    dig 2
    <
    bz getWithAuthList_after_for@9
    dig 3
    extract 2 0
    dig 1
    pushint 32 // 32
    *
    pushint 32 // 32
    extract3 // on error: index access is out of bounds
    dup
    bury 8
    // smart_contracts/escreg/contract.algo.ts:282
    // const addr4 = address.bytes.slice(0, 4).toFixed({ strategy: 'unsafe-cast', length: 4 })
    dup
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_2 // 4
    dig 2
    >=
    intc_2 // 4
    uncover 3
    uncover 2
    select
    substring3
    dup
    bury 11
    // smart_contracts/escreg/contract.algo.ts:284
    // let appId: uint64 = 0
    intc_0 // 0
    bury 7
    // smart_contracts/escreg/contract.algo.ts:285
    // if (this.apps(addr4).exists) {
    box_len
    bury 1
    bz getWithAuthList_after_if_else@5
    // smart_contracts/escreg/contract.algo.ts:286
    // const apps = this.apps(addr4).value as Readonly<uint64[]>
    dig 9
    box_get
    assert // Box must have value
    // smart_contracts/escreg/contract.algo.ts:287
    // appId = this.findAddr(address, apps)
    dig 7
    swap
    callsub findAddr
    bury 6

getWithAuthList_after_if_else@5:
    // smart_contracts/escreg/contract.algo.ts:290
    // const authAddr = address.native.authAddress
    dig 6
    acct_params_get AcctAuthAddr
    swap
    dup
    cover 2
    bury 11
    assert // account funded
    // smart_contracts/escreg/contract.algo.ts:291
    // const authAddr4 = authAddr.bytes.slice(0, 4).toFixed({ strategy: 'unsafe-cast', length: 4 })
    dup
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_2 // 4
    dig 2
    >=
    intc_2 // 4
    uncover 3
    uncover 2
    select
    substring3
    dup
    bury 9
    // smart_contracts/escreg/contract.algo.ts:293
    // let authAppId: uint64 = 0
    intc_0 // 0
    bury 6
    // smart_contracts/escreg/contract.algo.ts:294
    // if (this.apps(authAddr4).exists) {
    box_len
    bury 1
    bz getWithAuthList_after_if_else@7
    // smart_contracts/escreg/contract.algo.ts:295
    // const apps = this.apps(authAddr4).value as Readonly<uint64[]>
    dig 7
    box_get
    assert // Box must have value
    // smart_contracts/escreg/contract.algo.ts:296
    // authAppId = this.findAddr(new Address(authAddr), apps)
    dig 9
    swap
    callsub findAddr
    bury 5

getWithAuthList_after_if_else@7:
    // smart_contracts/escreg/contract.algo.ts:299
    // results.push({ appId, authAppId })
    dig 5
    itob
    dig 5
    itob
    concat
    dig 3
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 3
    dup
    intc_1 // 1
    +
    bury 1
    b getWithAuthList_for_header@2

getWithAuthList_after_for@9:
    // smart_contracts/escreg/contract.algo.ts:277
    // @abimethod({ readonly: true, validateEncoding: 'unsafe-disabled' })
    bytec_2 // 0x151f7c75
    dig 3
    concat
    log
    intc_1 // 1
    return


// smart_contracts/escreg/contract.algo.ts::Escreg.getList[routing]() -> void:
getList:
    intc_0 // 0
    dup
    // smart_contracts/escreg/contract.algo.ts:310
    // @abimethod({ readonly: true, validateEncoding: 'unsafe-disabled' })
    txna ApplicationArgs 1
    // smart_contracts/escreg/contract.algo.ts:312
    // let apps: uint64[] = []
    bytec 6 // 0x0000
    // smart_contracts/escreg/contract.algo.ts:310
    // @abimethod({ readonly: true, validateEncoding: 'unsafe-disabled' })
    txna ApplicationArgs 1
    // smart_contracts/escreg/contract.algo.ts:315
    // for (const address of addresses) {
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 0

getList_for_header@2:
    // smart_contracts/escreg/contract.algo.ts:315
    // for (const address of addresses) {
    dup
    dig 2
    <
    bz getList_after_for@8
    dig 3
    extract 2 0
    dig 1
    pushint 32 // 32
    *
    pushint 32 // 32
    extract3 // on error: index access is out of bounds
    dup
    bury 6
    // smart_contracts/escreg/contract.algo.ts:316
    // const addr4 = address.bytes.slice(0, 4).toFixed({ strategy: 'unsafe-cast', length: 4 })
    dup
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_2 // 4
    dig 2
    >=
    intc_2 // 4
    uncover 3
    uncover 2
    select
    substring3
    dup
    bury 7
    // smart_contracts/escreg/contract.algo.ts:318
    // if (!this.apps(addr4).exists) {
    box_len
    bury 1
    bnz getList_after_if_else@5
    // smart_contracts/escreg/contract.algo.ts:319
    // apps = [...apps, zero]
    dig 2
    pushbytes 0x0000000000000000
    concat // on error: max array length exceeded
    dup
    extract 2 0
    len
    intc_3 // 8
    /
    itob
    extract 6 2
    replace2 0
    bury 3

getList_block@6:
    dup
    intc_1 // 1
    +
    bury 1
    b getList_for_header@2

getList_after_if_else@5:
    // smart_contracts/escreg/contract.algo.ts:323
    // const appList = this.apps(addr4).value as Readonly<uint64[]>
    dig 5
    box_get
    assert // Box must have value
    // smart_contracts/escreg/contract.algo.ts:324
    // apps = [...apps, this.findAddr(address, appList)]
    dig 5
    swap
    callsub findAddr
    itob
    bytec 4 // 0x0001
    swap
    concat
    extract 2 0
    dig 3
    swap
    concat // on error: max array length exceeded
    dup
    extract 2 0
    len
    intc_3 // 8
    /
    itob
    extract 6 2
    replace2 0
    bury 3
    b getList_block@6

getList_after_for@8:
    // smart_contracts/escreg/contract.algo.ts:310
    // @abimethod({ readonly: true, validateEncoding: 'unsafe-disabled' })
    bytec_2 // 0x151f7c75
    dig 3
    concat
    log
    intc_1 // 1
    return


// smart_contracts/escreg/contract.algo.ts::Escreg.mustGetList[routing]() -> void:
mustGetList:
    intc_0 // 0
    dup
    bytec_3 // ""
    // smart_contracts/escreg/contract.algo.ts:335
    // @abimethod({ readonly: true, validateEncoding: 'unsafe-disabled' })
    txna ApplicationArgs 1
    // smart_contracts/escreg/contract.algo.ts:337
    // let apps: uint64[] = []
    bytec 6 // 0x0000
    // smart_contracts/escreg/contract.algo.ts:335
    // @abimethod({ readonly: true, validateEncoding: 'unsafe-disabled' })
    txna ApplicationArgs 1
    // smart_contracts/escreg/contract.algo.ts:338
    // for (const address of addresses) {
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 0

mustGetList_for_header@2:
    // smart_contracts/escreg/contract.algo.ts:338
    // for (const address of addresses) {
    dup
    dig 2
    <
    bz mustGetList_after_for@7
    dig 3
    extract 2 0
    dig 1
    pushint 32 // 32
    *
    pushint 32 // 32
    extract3 // on error: index access is out of bounds
    dup
    bury 7
    // smart_contracts/escreg/contract.algo.ts:339
    // const addr4 = address.bytes.slice(0, 4).toFixed({ strategy: 'unsafe-cast', length: 4 })
    dup
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_2 // 4
    dig 2
    >=
    intc_2 // 4
    uncover 3
    uncover 2
    select
    substring3
    dup
    bury 8
    // smart_contracts/escreg/contract.algo.ts:341
    // if (!this.apps(addr4).exists) {
    box_len
    bury 1
    bnz mustGetList_after_if_else@5
    // smart_contracts/escreg/contract.algo.ts:342
    // ensure(false, errAppNotRegistered)
    bytec 5 // "ERR:404"
    // smart_contracts/common.algo.ts:5
    // log(message)
    log
    // smart_contracts/common.algo.ts:6
    // err()
    err

mustGetList_after_if_else@5:
    // smart_contracts/escreg/contract.algo.ts:345
    // const appList = this.apps(addr4).value as Readonly<uint64[]>
    dig 6
    box_get
    assert // Box must have value
    // smart_contracts/escreg/contract.algo.ts:346
    // const matchingAppID = this.findAddr(address, appList)
    dig 6
    swap
    callsub findAddr
    dup
    bury 6
    // smart_contracts/common.algo.ts:4
    // if (!condition) {
    bnz mustGetList_after_if_else@10
    // smart_contracts/escreg/contract.algo.ts:348
    // ensure(matchingAppID !== 0, errAppNotRegistered)
    bytec 5 // "ERR:404"
    // smart_contracts/common.algo.ts:5
    // log(message)
    log
    // smart_contracts/common.algo.ts:6
    // err()
    err

mustGetList_after_if_else@10:
    // smart_contracts/escreg/contract.algo.ts:349
    // apps = [...apps, matchingAppID]
    dig 4
    itob
    bytec 4 // 0x0001
    swap
    concat
    extract 2 0
    dig 3
    swap
    concat // on error: max array length exceeded
    dup
    extract 2 0
    len
    intc_3 // 8
    /
    itob
    extract 6 2
    replace2 0
    bury 3
    dup
    intc_1 // 1
    +
    bury 1
    b mustGetList_for_header@2

mustGetList_after_for@7:
    // smart_contracts/escreg/contract.algo.ts:335
    // @abimethod({ readonly: true, validateEncoding: 'unsafe-disabled' })
    bytec_2 // 0x151f7c75
    dig 3
    concat
    log
    intc_1 // 1
    return


// smart_contracts/escreg/contract.algo.ts::Escreg.increaseBudget[routing]() -> void:
increaseBudget:
    // smart_contracts/escreg/contract.algo.ts:358
    // @abimethod({ validateEncoding: 'unsafe-disabled' })
    txna ApplicationArgs 1
    btoi
    // smart_contracts/escreg/contract.algo.ts:360
    // for (let i: uint64 = 0; i < itxns; i++) {
    intc_0 // 0

increaseBudget_while_top@2:
    // smart_contracts/escreg/contract.algo.ts:360
    // for (let i: uint64 = 0; i < itxns; i++) {
    dup
    dig 2
    <
    bz increaseBudget_after_while@5
    // smart_contracts/escreg/contract.algo.ts:361-368
    // itxn
    //   .applicationCall({
    //     approvalProgram: RETURN_TRUE,
    //     clearStateProgram: RETURN_TRUE,
    //     onCompletion: OnCompleteAction.DeleteApplication,
    //     fee: 0,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/escreg/contract.algo.ts:365
    // onCompletion: OnCompleteAction.DeleteApplication,
    pushint 5 // 5
    itxn_field OnCompletion
    // smart_contracts/escreg/contract.algo.ts:364
    // clearStateProgram: RETURN_TRUE,
    bytec 8 // 0x0a8101
    itxn_field ClearStateProgramPages
    // smart_contracts/escreg/contract.algo.ts:363
    // approvalProgram: RETURN_TRUE,
    bytec 8 // 0x0a8101
    itxn_field ApprovalProgramPages
    // smart_contracts/escreg/contract.algo.ts:361-367
    // itxn
    //   .applicationCall({
    //     approvalProgram: RETURN_TRUE,
    //     clearStateProgram: RETURN_TRUE,
    //     onCompletion: OnCompleteAction.DeleteApplication,
    //     fee: 0,
    //   })
    pushint 6 // 6
    itxn_field TypeEnum
    // smart_contracts/escreg/contract.algo.ts:366
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/escreg/contract.algo.ts:361-368
    // itxn
    //   .applicationCall({
    //     approvalProgram: RETURN_TRUE,
    //     clearStateProgram: RETURN_TRUE,
    //     onCompletion: OnCompleteAction.DeleteApplication,
    //     fee: 0,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/escreg/contract.algo.ts:360
    // for (let i: uint64 = 0; i < itxns; i++) {
    dup
    intc_1 // 1
    +
    bury 1
    b increaseBudget_while_top@2

increaseBudget_after_while@5:
    // smart_contracts/escreg/contract.algo.ts:358
    // @abimethod({ validateEncoding: 'unsafe-disabled' })
    intc_1 // 1
    return


// smart_contracts/mbr-manager/contract.algo.ts::MbrManager.depositCredits[routing]() -> void:
depositCredits:
    intc_0 // 0
    bytec_3 // ""
    // smart_contracts/mbr-manager/contract.algo.ts:38
    // public depositCredits(creditor: Account, txn: gtxn.PaymentTxn) {
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txn GroupIndex
    intc_1 // 1
    -
    dupn 2
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/mbr-manager/contract.algo.ts:39
    // ensure(txn.receiver === Global.currentApplicationAddress, errReceiver)
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/common.algo.ts:4
    // if (!condition) {
    bnz depositCredits_after_if_else@7
    // smart_contracts/mbr-manager/contract.algo.ts:39
    // ensure(txn.receiver === Global.currentApplicationAddress, errReceiver)
    bytec 9 // "ERR:RCV"
    // smart_contracts/common.algo.ts:5
    // log(message)
    log
    // smart_contracts/common.algo.ts:6
    // err()
    err

depositCredits_after_if_else@7:
    // smart_contracts/mbr-manager/contract.algo.ts:40
    // ensure(txn.amount > 0, errAmt)
    dup
    gtxns Amount
    dup
    bury 4
    // smart_contracts/common.algo.ts:4
    // if (!condition) {
    bnz depositCredits_after_if_else@11
    // smart_contracts/mbr-manager/contract.algo.ts:40
    // ensure(txn.amount > 0, errAmt)
    bytec 10 // "ERR:AMT"
    // smart_contracts/common.algo.ts:5
    // log(message)
    log
    // smart_contracts/common.algo.ts:6
    // err()
    err

depositCredits_after_if_else@11:
    // smart_contracts/mbr-manager/contract.algo.ts:7
    // userCredits = BoxMap<Account, uint64>({ keyPrefix: 'c' })
    bytec_0 // "c"
    dig 2
    concat
    dup
    bury 5
    // smart_contracts/mbr-manager/contract.algo.ts:41
    // const current: uint64 = this.userCredits(creditor).exists ? this.userCredits(creditor).value : 0
    box_len
    bury 1
    bz depositCredits_ternary_false@3
    dig 3
    box_get
    assert // Box must have value
    btoi

depositCredits_ternary_merge@4:
    // smart_contracts/mbr-manager/contract.algo.ts:43
    // const mbrBefore = Global.currentApplicationAddress.minBalance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // smart_contracts/mbr-manager/contract.algo.ts:44
    // this.userCredits(creditor).value = current + txn.amount
    swap
    dig 4
    +
    itob
    dig 5
    swap
    box_put
    // smart_contracts/mbr-manager/contract.algo.ts:46
    // this.manageMbrCredits(mbrBefore)
    callsub manageMbrCredits
    // smart_contracts/mbr-manager/contract.algo.ts:38
    // public depositCredits(creditor: Account, txn: gtxn.PaymentTxn) {
    intc_1 // 1
    return

depositCredits_ternary_false@3:
    // smart_contracts/mbr-manager/contract.algo.ts:41
    // const current: uint64 = this.userCredits(creditor).exists ? this.userCredits(creditor).value : 0
    intc_0 // 0
    b depositCredits_ternary_merge@4


// smart_contracts/mbr-manager/contract.algo.ts::MbrManager.withdrawCredits[routing]() -> void:
withdrawCredits:
    // smart_contracts/mbr-manager/contract.algo.ts:54
    // const mbrBefore = Global.currentApplicationAddress.minBalance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // smart_contracts/mbr-manager/contract.algo.ts:7
    // userCredits = BoxMap<Account, uint64>({ keyPrefix: 'c' })
    bytec_0 // "c"
    // smart_contracts/mbr-manager/contract.algo.ts:56
    // ensure(this.userCredits(Txn.sender).exists, errAmt)
    txn Sender
    // smart_contracts/mbr-manager/contract.algo.ts:7
    // userCredits = BoxMap<Account, uint64>({ keyPrefix: 'c' })
    concat
    // smart_contracts/mbr-manager/contract.algo.ts:56
    // ensure(this.userCredits(Txn.sender).exists, errAmt)
    box_len
    bury 1
    // smart_contracts/common.algo.ts:4
    // if (!condition) {
    bnz withdrawCredits_after_if_else@3
    // smart_contracts/mbr-manager/contract.algo.ts:56
    // ensure(this.userCredits(Txn.sender).exists, errAmt)
    bytec 10 // "ERR:AMT"
    // smart_contracts/common.algo.ts:5
    // log(message)
    log
    // smart_contracts/common.algo.ts:6
    // err()
    err

withdrawCredits_after_if_else@3:
    // smart_contracts/mbr-manager/contract.algo.ts:7
    // userCredits = BoxMap<Account, uint64>({ keyPrefix: 'c' })
    bytec_0 // "c"
    // smart_contracts/mbr-manager/contract.algo.ts:57
    // const credit: uint64 = this.userCredits(Txn.sender).value
    txn Sender
    // smart_contracts/mbr-manager/contract.algo.ts:7
    // userCredits = BoxMap<Account, uint64>({ keyPrefix: 'c' })
    concat
    // smart_contracts/mbr-manager/contract.algo.ts:57
    // const credit: uint64 = this.userCredits(Txn.sender).value
    box_get
    assert // Box must have value
    btoi
    // smart_contracts/mbr-manager/contract.algo.ts:7
    // userCredits = BoxMap<Account, uint64>({ keyPrefix: 'c' })
    bytec_0 // "c"
    // smart_contracts/mbr-manager/contract.algo.ts:60
    // this.userCredits(Txn.sender).delete()
    txn Sender
    // smart_contracts/mbr-manager/contract.algo.ts:7
    // userCredits = BoxMap<Account, uint64>({ keyPrefix: 'c' })
    concat
    // smart_contracts/mbr-manager/contract.algo.ts:60
    // this.userCredits(Txn.sender).delete()
    box_del
    pop
    // smart_contracts/mbr-manager/contract.algo.ts:61
    // const mbrAfter = Global.currentApplicationAddress.minBalance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // smart_contracts/mbr-manager/contract.algo.ts:62
    // const finalCredit: uint64 = credit + (mbrBefore - mbrAfter)
    dig 2
    swap
    -
    +
    // smart_contracts/mbr-manager/contract.algo.ts:64-70
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: finalCredit,
    //     fee: 0,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/mbr-manager/contract.algo.ts:66
    // receiver: Txn.sender,
    txn Sender
    itxn_field Receiver
    itxn_field Amount
    // smart_contracts/mbr-manager/contract.algo.ts:64-69
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: finalCredit,
    //     fee: 0,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/mbr-manager/contract.algo.ts:68
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/mbr-manager/contract.algo.ts:64-70
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: finalCredit,
    //     fee: 0,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/mbr-manager/contract.algo.ts:53
    // public withdrawCredits() {
    intc_1 // 1
    return


// smart_contracts/escreg/contract.algo.ts::Escreg.adminOnly() -> void:
adminOnly:
    // smart_contracts/escreg/contract.algo.ts:87
    // ensure(Txn.sender === this.admin.value.native, errAuth)
    txn Sender
    intc_0 // 0
    // smart_contracts/escreg/contract.algo.ts:28
    // admin = GlobalState<Address>({ initialValue: new Address(Txn.sender) })
    bytec 7 // "admin"
    // smart_contracts/escreg/contract.algo.ts:87
    // ensure(Txn.sender === this.admin.value.native, errAuth)
    app_global_get_ex
    assert // check GlobalState exists
    ==
    // smart_contracts/common.algo.ts:4
    // if (!condition) {
    bnz adminOnly_after_if_else@3
    // smart_contracts/escreg/contract.algo.ts:87
    // ensure(Txn.sender === this.admin.value.native, errAuth)
    pushbytes "ERR:AUTH"
    // smart_contracts/common.algo.ts:5
    // log(message)
    log
    // smart_contracts/common.algo.ts:6
    // err()
    err

adminOnly_after_if_else@3:
    retsub


// smart_contracts/escreg/contract.algo.ts::Escreg.deriveAddrPrefix(appId: uint64) -> bytes:
deriveAddrPrefix:
    // smart_contracts/escreg/contract.algo.ts:141
    // private deriveAddrPrefix(appId: uint64): bytes<4> {
    proto 1 1
    // smart_contracts/escreg/contract.algo.ts:142
    // return sha512_256(Bytes`appID`.concat(op.itob(appId)))
    frame_dig -1
    itob
    bytec 11 // "appID"
    swap
    concat
    sha512_256
    // smart_contracts/escreg/contract.algo.ts:142-143
    // return sha512_256(Bytes`appID`.concat(op.itob(appId)))
    //   .slice(0, 4)
    substring 0 4
    // smart_contracts/escreg/contract.algo.ts:142-144
    // return sha512_256(Bytes`appID`.concat(op.itob(appId)))
    //   .slice(0, 4)
    //   .toFixed({ strategy: 'unsafe-cast', length: 4 })
    retsub


// smart_contracts/escreg/contract.algo.ts::Escreg.appendAppId(key: bytes, appId: uint64) -> void:
appendAppId:
    // smart_contracts/escreg/contract.algo.ts:161
    // private appendAppId(key: bytes<4>, appId: uint64) {
    proto 2 0
    // smart_contracts/escreg/contract.algo.ts:162
    // const existing = this.apps(key).value as Readonly<uint64[]>
    frame_dig -2
    box_get
    assert // Box must have value
    // smart_contracts/escreg/contract.algo.ts:162-163
    // const existing = this.apps(key).value as Readonly<uint64[]>
    // for (const existingId of existing) {
    frame_dig -2
    intc_0 // 0
    pushint 2 // 2
    box_extract
    btoi
    intc_0 // 0

appendAppId_for_header@1:
    // smart_contracts/escreg/contract.algo.ts:163
    // for (const existingId of existing) {
    frame_dig 2
    frame_dig 1
    <
    bz appendAppId_after_for@6
    // smart_contracts/escreg/contract.algo.ts:162-163
    // const existing = this.apps(key).value as Readonly<uint64[]>
    // for (const existingId of existing) {
    frame_dig 2
    intc_3 // 8
    *
    pushint 2 // 2
    +
    frame_dig -2
    swap
    intc_3 // 8
    box_extract
    // smart_contracts/escreg/contract.algo.ts:163
    // for (const existingId of existing) {
    btoi
    // smart_contracts/escreg/contract.algo.ts:164
    // if (existingId === appId) {
    frame_dig -1
    ==
    bz appendAppId_after_if_else@4
    // smart_contracts/escreg/contract.algo.ts:165
    // return
    retsub

appendAppId_after_if_else@4:
    frame_dig 2
    intc_1 // 1
    +
    frame_bury 2
    b appendAppId_for_header@1

appendAppId_after_for@6:
    // smart_contracts/escreg/contract.algo.ts:168
    // this.apps(key).value = [...existing, appId]
    frame_dig -1
    itob
    bytec 4 // 0x0001
    swap
    concat
    extract 2 0
    frame_dig 0
    swap
    concat // on error: max array length exceeded
    dup
    extract 2 0
    len
    intc_3 // 8
    /
    itob
    extract 6 2
    replace2 0
    frame_dig -2
    box_del
    pop
    frame_dig -2
    swap
    box_put
    // smart_contracts/escreg/contract.algo.ts:169
    // this.counter.value += 1
    intc_0 // 0
    // smart_contracts/escreg/contract.algo.ts:32
    // counter = GlobalState<uint64>({ initialValue: 0 })
    bytec_1 // "counter"
    // smart_contracts/escreg/contract.algo.ts:169
    // this.counter.value += 1
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    +
    // smart_contracts/escreg/contract.algo.ts:32
    // counter = GlobalState<uint64>({ initialValue: 0 })
    bytec_1 // "counter"
    // smart_contracts/escreg/contract.algo.ts:169
    // this.counter.value += 1
    swap
    app_global_put
    retsub


// smart_contracts/escreg/contract.algo.ts::Escreg.findAddr(address: bytes, apps: bytes) -> uint64:
findAddr:
    // smart_contracts/escreg/contract.algo.ts:178
    // private findAddr(address: Address, apps: Readonly<uint64[]>): uint64 {
    proto 2 1
    bytec_3 // ""
    // smart_contracts/escreg/contract.algo.ts:179
    // for (let i: uint64 = 0; i < apps.length; i++) {
    intc_0 // 0

findAddr_while_top@1:
    // smart_contracts/escreg/contract.algo.ts:179
    // for (let i: uint64 = 0; i < apps.length; i++) {
    frame_dig -1
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    frame_dig 1
    >
    bz findAddr_after_while@5
    // smart_contracts/escreg/contract.algo.ts:180
    // if (address.native.bytes === this.deriveAddr(apps[i])) {
    frame_dig -1
    extract 2 0
    frame_dig 1
    intc_3 // 8
    *
    extract_uint64
    dup
    frame_bury 0
    // smart_contracts/escreg/contract.algo.ts:153
    // return sha512_256(Bytes`appID`.concat(op.itob(appId)))
    itob
    bytec 11 // "appID"
    swap
    concat
    sha512_256
    // smart_contracts/escreg/contract.algo.ts:180
    // if (address.native.bytes === this.deriveAddr(apps[i])) {
    frame_dig -2
    ==
    bz findAddr_after_if_else@4
    // smart_contracts/escreg/contract.algo.ts:181
    // return apps[i]
    retsub

findAddr_after_if_else@4:
    // smart_contracts/escreg/contract.algo.ts:179
    // for (let i: uint64 = 0; i < apps.length; i++) {
    frame_dig 1
    intc_1 // 1
    +
    frame_bury 1
    b findAddr_while_top@1

findAddr_after_while@5:
    // smart_contracts/escreg/contract.algo.ts:184
    // return 0
    intc_0 // 0
    frame_bury 0
    retsub


// smart_contracts/mbr-manager/contract.algo.ts::MbrManager.manageMbrCredits(mbrBefore: uint64) -> void:
manageMbrCredits:
    // smart_contracts/mbr-manager/contract.algo.ts:15
    // protected manageMbrCredits(mbrBefore: uint64) {
    proto 1 0
    bytec_3 // ""
    dupn 2
    // smart_contracts/mbr-manager/contract.algo.ts:16
    // const mbrAfter = Global.currentApplicationAddress.minBalance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    swap
    dup
    uncover 2
    assert // account funded
    // smart_contracts/mbr-manager/contract.algo.ts:17
    // if (mbrAfter === mbrBefore) return
    frame_dig -1
    ==
    bz manageMbrCredits_else_body@2
    retsub

manageMbrCredits_else_body@2:
    // smart_contracts/mbr-manager/contract.algo.ts:18
    // else if (mbrAfter > mbrBefore) {
    frame_dig 3
    frame_dig -1
    >
    bz manageMbrCredits_else_body@7
    // smart_contracts/mbr-manager/contract.algo.ts:19
    // const creditNeeded: uint64 = mbrAfter - mbrBefore
    frame_dig 3
    frame_dig -1
    -
    frame_bury 0
    // smart_contracts/mbr-manager/contract.algo.ts:7
    // userCredits = BoxMap<Account, uint64>({ keyPrefix: 'c' })
    bytec_0 // "c"
    // smart_contracts/mbr-manager/contract.algo.ts:20
    // const userCredit: uint64 = this.userCredits(Txn.sender).exists ? this.userCredits(Txn.sender).value : 0
    txn Sender
    // smart_contracts/mbr-manager/contract.algo.ts:7
    // userCredits = BoxMap<Account, uint64>({ keyPrefix: 'c' })
    concat
    // smart_contracts/mbr-manager/contract.algo.ts:20
    // const userCredit: uint64 = this.userCredits(Txn.sender).exists ? this.userCredits(Txn.sender).value : 0
    box_len
    bury 1
    bz manageMbrCredits_ternary_false@5
    // smart_contracts/mbr-manager/contract.algo.ts:7
    // userCredits = BoxMap<Account, uint64>({ keyPrefix: 'c' })
    bytec_0 // "c"
    // smart_contracts/mbr-manager/contract.algo.ts:20
    // const userCredit: uint64 = this.userCredits(Txn.sender).exists ? this.userCredits(Txn.sender).value : 0
    txn Sender
    // smart_contracts/mbr-manager/contract.algo.ts:7
    // userCredits = BoxMap<Account, uint64>({ keyPrefix: 'c' })
    concat
    // smart_contracts/mbr-manager/contract.algo.ts:20
    // const userCredit: uint64 = this.userCredits(Txn.sender).exists ? this.userCredits(Txn.sender).value : 0
    box_get
    assert // Box must have value
    btoi
    frame_bury 2

manageMbrCredits_ternary_merge@6:
    // smart_contracts/mbr-manager/contract.algo.ts:21
    // ensure(userCredit >= creditNeeded, errCredit)
    frame_dig 2
    frame_dig 0
    >=
    // smart_contracts/common.algo.ts:4
    // if (!condition) {
    bnz manageMbrCredits_after_if_else@15
    // smart_contracts/mbr-manager/contract.algo.ts:21
    // ensure(userCredit >= creditNeeded, errCredit)
    pushbytes "ERR:CRD"
    // smart_contracts/common.algo.ts:5
    // log(message)
    log
    // smart_contracts/common.algo.ts:6
    // err()
    err

manageMbrCredits_after_if_else@15:
    // smart_contracts/mbr-manager/contract.algo.ts:22
    // this.userCredits(Txn.sender).value = userCredit - creditNeeded
    frame_dig 2
    frame_dig 0
    -
    // smart_contracts/mbr-manager/contract.algo.ts:7
    // userCredits = BoxMap<Account, uint64>({ keyPrefix: 'c' })
    bytec_0 // "c"
    // smart_contracts/mbr-manager/contract.algo.ts:22
    // this.userCredits(Txn.sender).value = userCredit - creditNeeded
    txn Sender
    // smart_contracts/mbr-manager/contract.algo.ts:7
    // userCredits = BoxMap<Account, uint64>({ keyPrefix: 'c' })
    concat
    // smart_contracts/mbr-manager/contract.algo.ts:22
    // this.userCredits(Txn.sender).value = userCredit - creditNeeded
    swap
    itob
    box_put
    retsub

manageMbrCredits_ternary_false@5:
    // smart_contracts/mbr-manager/contract.algo.ts:20
    // const userCredit: uint64 = this.userCredits(Txn.sender).exists ? this.userCredits(Txn.sender).value : 0
    intc_0 // 0
    frame_bury 2
    b manageMbrCredits_ternary_merge@6

manageMbrCredits_else_body@7:
    // smart_contracts/mbr-manager/contract.algo.ts:24
    // const creditToReturn: uint64 = mbrBefore - mbrAfter
    frame_dig -1
    frame_dig 3
    -
    frame_bury 1
    // smart_contracts/mbr-manager/contract.algo.ts:7
    // userCredits = BoxMap<Account, uint64>({ keyPrefix: 'c' })
    bytec_0 // "c"
    // smart_contracts/mbr-manager/contract.algo.ts:25
    // ensure(this.userCredits(Txn.sender).exists, errReceiver)
    txn Sender
    // smart_contracts/mbr-manager/contract.algo.ts:7
    // userCredits = BoxMap<Account, uint64>({ keyPrefix: 'c' })
    concat
    // smart_contracts/mbr-manager/contract.algo.ts:25
    // ensure(this.userCredits(Txn.sender).exists, errReceiver)
    box_len
    bury 1
    // smart_contracts/common.algo.ts:4
    // if (!condition) {
    bnz manageMbrCredits_after_if_else@11
    // smart_contracts/mbr-manager/contract.algo.ts:25
    // ensure(this.userCredits(Txn.sender).exists, errReceiver)
    bytec 9 // "ERR:RCV"
    // smart_contracts/common.algo.ts:5
    // log(message)
    log
    // smart_contracts/common.algo.ts:6
    // err()
    err

manageMbrCredits_after_if_else@11:
    // smart_contracts/mbr-manager/contract.algo.ts:7
    // userCredits = BoxMap<Account, uint64>({ keyPrefix: 'c' })
    bytec_0 // "c"
    // smart_contracts/mbr-manager/contract.algo.ts:26
    // this.userCredits(Txn.sender).value += creditToReturn
    txn Sender
    // smart_contracts/mbr-manager/contract.algo.ts:7
    // userCredits = BoxMap<Account, uint64>({ keyPrefix: 'c' })
    concat
    // smart_contracts/mbr-manager/contract.algo.ts:26
    // this.userCredits(Txn.sender).value += creditToReturn
    box_get
    assert // Box must have value
    btoi
    frame_dig 1
    +
    // smart_contracts/mbr-manager/contract.algo.ts:7
    // userCredits = BoxMap<Account, uint64>({ keyPrefix: 'c' })
    bytec_0 // "c"
    // smart_contracts/mbr-manager/contract.algo.ts:26
    // this.userCredits(Txn.sender).value += creditToReturn
    txn Sender
    // smart_contracts/mbr-manager/contract.algo.ts:7
    // userCredits = BoxMap<Account, uint64>({ keyPrefix: 'c' })
    concat
    // smart_contracts/mbr-manager/contract.algo.ts:26
    // this.userCredits(Txn.sender).value += creditToReturn
    swap
    itob
    box_put
    retsub
